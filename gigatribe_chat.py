#!/usr/bin/env python
'''

GigaTribe v3 Chat Parser

Parses chat files generated by the P2P application GigaTribe v3 and outputs the data to CSV format.

Chat files have the naming convention "chathistory_<userid1>_<userid2>.bin" where:
* userid1 is the user ID of the "logged in" user and 
* userid2 is the user ID of the remote user they are chatting with.
 
Author: 	Syd Pleno
Contact:	syd.pleno@gmail.com

Copyright 2012 Syd Pleno - All rights reserved

TODO: embed image in chatlog using base-64 encoding?
'''

import struct
import sys
from os.path import basename
from optparse import OptionParser
from DateConverter import DateConverter

# http://code.activestate.com/recipes/466341-guaranteed-conversion-to-unicode-or-byte-string/
def safe_unicode(obj, *args):
    """ return the unicode representation of obj """
    try:
        return unicode(obj, *args)
    except UnicodeDecodeError:
        # obj is byte string
        ascii_text = str(obj).encode('string_escape')
        return unicode(ascii_text)

def safe_str(obj):
    """ return the byte string representation of obj """
    try:
        return str(obj)
    except UnicodeEncodeError:
        # obj is unicode
        return unicode(obj).encode('unicode_escape')

def unpack_qstring(h):
	str_len = struct.unpack(">I", h[0:4])
	qstring = h[4:].decode("utf-16-be")
	return qstring

def unpack_stream_qstring(h):
	str_len = struct.unpack(">I", h.read(4))[0]
	if str_len == 0xffffffff:
		return None
	return h.read(str_len).decode("utf-16-be")

def qdatetimeToStr(utc, date, time):
	(D,M,Y) = DateConverter.JDNtoGD(date)
	date_format = "%i-%i-%i %i:%02i:%06.3f"
	milliseconds = time
	hours, milliseconds = divmod(milliseconds, 3600000)
	minutes, milliseconds = divmod(milliseconds, 60000)
	seconds = float(milliseconds) / 1000
	if utc:
		date_format += " UTC"
	return date_format % (D, M, Y, hours, minutes, seconds)
	
def unpack_stream_qdatetime(h):
	date = struct.unpack(">I", h.read(4))[0]
	time = struct.unpack(">I", h.read(4))[0]
	utc = struct.unpack("B", h.read(1))[0]
	return qdatetimeToStr(utc, date, time)
	
class GigaTribe_v3_Chat:
	
	def __init__(self, _name):
		self.name = _name
		self.records = []
				
	def unpack_stream_record(self, h):
		start = h.tell()
		message_id = struct.unpack(">I", h.read(4))[0]
		offline = struct.unpack("b", h.read(1))[0]
		timestamp = unpack_stream_qdatetime(h)
		sender_id = struct.unpack(">I", h.read(4))[0]
		sender_name = unpack_stream_qstring(h)
		num_recv_ids = struct.unpack(">I", h.read(4))[0]
		recv_ids = []
		for id in range(num_recv_ids):
			recv_ids.append(struct.unpack(">I", h.read(4))[0])
		num_recv_names = struct.unpack(">I", h.read(4))[0]
		recv_names = []
		for id in range(num_recv_names):
			recv_names.append(unpack_stream_qstring(h))
		message_v2 = unpack_stream_qstring(h)
		message_html = unpack_stream_qstring(h)
		
		supp_message = unpack_stream_qstring(h)
		bytes_read = struct.unpack(">Q", h.read(8))[0]
		return (message_id, offline, timestamp, sender_id, sender_name, 
				recv_ids, recv_names, message_v2, message_html, supp_message, 
				start, bytes_read)
	
	def unpack_header(self, h):
		signature = struct.unpack(">h", h.read(2))[0]
		version = unpack_stream_qstring(h)
		return (signature, version)
		
	def ParseFile(self, h):
		try:
			(self.signature, self.version) = self.unpack_header(h)
			if not (self.signature == 25448):
				return
		except:
			print >> sys.stderr, "Error: unable to parse header"
			return
		try:
			while True:
				self.records.append(self.unpack_stream_record(h))
		except:
			print "Parsed",len(self.records),"chat records"
			return
					
		
	def PrintCSV(self,num_column=False):
		'''
		Dumps records to stdout, ignoring the HTML version of the message
		'''
		headers = ["#", "Message ID", "Offline", "Timestamp", "Sender ID", 
					"Sender Name", "Recipient IDs", "Recipient Names", 
					"Message", #"Message (HTML)",
					"Supp Message", "Record Offset", "Record Size"]
		if num_column:
			print ",".join(x for x in headers)
		else:
			print ",".join(x for x in headers[1:])
		for row, record in enumerate(self.records):
			line = ""
			if num_column:
				line = str(row+1)+","
			for v, y in enumerate(record):
				#print y
				if v == 8:	# skip over HTML message in the CSV report
					continue
				if isinstance(y, list):
					line += "\""+(",".join(str(z) for z in y))+"\","
				elif isinstance(y, int): #type(y) is IntType:
					line += "\""+str(y)+"\","
				else:
					try:
						line += "\""+safe_str(y)+"\","
					except:
						line += "\""+unicode(y, errors='ignore')+"\","
			print line
	
	def PrintHTML(self):
	
		headers = ["#", "Message ID", "Offline", "Timestamp", "Sender ID", 
					"Sender Name", "Recipient IDs", "Recipient Names", 
					"Message", "Message (HTML)",
					"Supp Message",  "Record Offset", "Record Size"]
		with open(basename(self.name)+".html", 'wb') as f:
			header = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">"
			header += "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">"
			header += "p, li { white-space: pre-wrap; }"
			header += "</style></head><body style=\" font-family:'Tahoma'; font-size:8pt; font-weight:400; font-style:normal;\">"
			f.write(header)
			f.write("<h3> Filename:" + self.name + "</h3>")
			table = "<table border=\"1\"><tr>"
			for h in headers:
				table += "<td>"+h+"</td>"
			f.write(table+"\n")	
			for x, record in enumerate(self.records):
				row = "<tr><td>"+str(x+1)+"</td>"
				for y, cell in enumerate(record):
					text = ""
					style = ""
					if y == 8:
						text = safe_str(cell)
						text = text.replace("src=\"/ressources", "src=\"./ressources")
						
						# there is a "neater way" to do this...prob through HTMLParser..
						attr_start = text.find("<body style=")
						if attr_start:
							end = text.find(">", attr_start)
							style = " " + text[attr_start+5:end]
						para_start = text.find("<p ")
						if para_start:
							end = text.find("</p>")
							text = text[para_start:end+4]
						
					elif isinstance(cell, list):	# should only be for recipient lists
						text = ",".join(safe_str(z) for z in cell)
					else:
						text = safe_str(cell)
					
					#if style:
					row += "<td" + style + ">"+text+"</td>"
					#else:
					#	row += "<td>"+text+"</td>"
				row += "</tr>\n"
				f.write(row)
			f.write("</tr></table>\n")
			footer = "</body></html>"
			f.write(footer);
		
def main():
	description = "Extracts chat records from GigaTribe Chat file"
	usage = "Usage: %prog [-n] <chatfile> (CSV)\nUsage: %prog -d <chatfile> (HTML)"
	optparser = OptionParser(usage=usage,description=description)
	optparser.add_option("-n", "--num_column", dest="num_column", 
						 action="store_true", default=False, 
						 help="Add Row Number to CSV row")
	optparser.add_option("-d", "--html_report", dest="do_html", action="store_true", default=False, help="Generate HTML report")
	(options, args) = optparser.parse_args()
	if len(args) < 1:
		print >> sys.stderr, "No input file"
		print >> sys.stderr, optparser.print_help()
		sys.exit()
	else:
		with open(args[0], 'rb') as f:
			chat = GigaTribe_v3_Chat(args[0])
			chat.ParseFile(f)
			if options.do_html:
				chat.PrintHTML()
			else:
				#print "Not implemented: use -d option instead"
				chat.PrintCSV(options.num_column)

if __name__ == "__main__":
	main()
	
